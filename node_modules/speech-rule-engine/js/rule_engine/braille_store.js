import { MathStore } from './math_store.js';
import { activate } from '../semantic_tree/semantic_annotations.js';
import { SemanticMap } from '../semantic_tree/semantic_attr.js';
export class BrailleStore extends MathStore {
    constructor() {
        super(...arguments);
        this.modality = 'braille';
        this.customTranscriptions = {
            '\u22ca': '⠈⠡⠳'
        };
    }
    evaluateString(str) {
        const descs = [];
        const text = Array.from(str);
        for (let i = 0; i < text.length; i++) {
            descs.push(this.evaluateCharacter(text[i]));
        }
        return descs;
    }
    annotations() {
        for (let i = 0, annotator; (annotator = this.annotators[i]); i++) {
            activate(this.locale, annotator);
        }
    }
}
export class EuroStore extends BrailleStore {
    constructor() {
        super(...arguments);
        this.locale = 'euro';
        this.customTranscriptions = {};
        this.customCommands = {
            '\\cdot': '*'
        };
    }
    evaluateString(str) {
        const regexp = /(\\[a-z]+)/i;
        const split = str.split(regexp);
        console.log(split);
        return super.evaluateString(this.cleanup(split).join(''));
    }
    cleanup(commands) {
        let result = [];
        for (const command of commands) {
            if (command.match(/^\\/)) {
                const custom = this.customCommands[command];
                result.push(custom ? custom : command);
                continue;
            }
            const chars = command.split('').map((x) => {
                const meaning = SemanticMap.Meaning.get(x);
                return meaning.type === "operator" ||
                    meaning.type === "relation"
                    ? ' ' + x
                    : x;
            });
            result = result.concat(chars);
        }
        return result;
    }
}

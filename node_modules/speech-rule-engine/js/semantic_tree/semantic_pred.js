import { NamedSymbol, SemanticMap } from './semantic_attr.js';
import { SemanticSecondary } from './semantic_meaning.js';
import { getEmbellishedInner } from './semantic_util.js';
export function isType(node, attr) {
    return node.type === attr;
}
function embellishedType(node, attr) {
    return node.embellished === attr;
}
export function isRole(node, attr) {
    return node.role === attr;
}
export function isAccent(node) {
    return (isType(node, "fence") ||
        isType(node, "punctuation") ||
        isType(node, "operator") ||
        isType(node, "relation"));
}
export function isSimpleFunctionScope(node) {
    const children = node.childNodes;
    if (children.length === 0) {
        return true;
    }
    if (children.length > 1) {
        return false;
    }
    const child = children[0];
    if (child.type === "infixop") {
        if (child.role !== "implicit") {
            return false;
        }
        if (child.childNodes.some((x) => isType(x, "infixop"))) {
            return false;
        }
    }
    return true;
}
export function isPrefixFunctionBoundary(node) {
    return ((isOperator(node) && !isRole(node, "division")) ||
        isType(node, "appl") ||
        isGeneralFunctionBoundary(node));
}
export function isBigOpBoundary(node) {
    return isOperator(node) || isGeneralFunctionBoundary(node);
}
export function isIntegralDxBoundary(firstNode, secondNode) {
    return (!!secondNode &&
        isType(secondNode, "identifier") &&
        SemanticMap.Secondary.has(firstNode.textContent, SemanticSecondary.D));
}
export function isIntegralDxBoundarySingle(node) {
    if (isType(node, "identifier")) {
        const firstChar = node.textContent[0];
        return (firstChar &&
            node.textContent[1] &&
            SemanticMap.Secondary.has(firstChar, SemanticSecondary.D));
    }
    return false;
}
export function isGeneralFunctionBoundary(node) {
    return isRelation(node) || isPunctuation(node);
}
export function isEmbellished(node) {
    if (node.embellished) {
        return node.embellished;
    }
    if (isEmbellishedType(node.type)) {
        return node.type;
    }
    return null;
}
function isEmbellishedType(type) {
    return (type === "operator" ||
        type === "relation" ||
        type === "fence" ||
        type === "punctuation");
}
export function isOperator(node) {
    return (isType(node, "operator") ||
        embellishedType(node, "operator"));
}
export function isRelation(node) {
    return (isType(node, "relation") ||
        embellishedType(node, "relation"));
}
export function isPunctuation(node) {
    return (isType(node, "punctuation") ||
        embellishedType(node, "punctuation"));
}
export function isFence(node) {
    return (isType(node, "fence") ||
        embellishedType(node, "fence"));
}
export function isElligibleEmbellishedFence(node) {
    if (!node || !isFence(node)) {
        return false;
    }
    if (!node.embellished) {
        return true;
    }
    return recurseBaseNode(node);
}
function bothSide(node) {
    return (isType(node, "tensor") &&
        (!isType(node.childNodes[1], "empty") ||
            !isType(node.childNodes[2], "empty")) &&
        (!isType(node.childNodes[3], "empty") ||
            !isType(node.childNodes[4], "empty")));
}
function recurseBaseNode(node) {
    if (!node.embellished) {
        return true;
    }
    if (bothSide(node)) {
        return false;
    }
    if (isRole(node, "close") && isType(node, "tensor")) {
        return false;
    }
    if (isRole(node, "open") &&
        (isType(node, "subscript") ||
            isType(node, "superscript"))) {
        return false;
    }
    return recurseBaseNode(node.childNodes[0]);
}
export function isTableOrMultiline(node) {
    return (!!node &&
        (isType(node, "table") || isType(node, "multiline")));
}
export function tableIsMatrixOrVector(node) {
    return (!!node && isFencedElement(node) && isTableOrMultiline(node.childNodes[0]));
}
export function isFencedElement(node) {
    return (!!node &&
        isType(node, "fenced") &&
        (isRole(node, "leftright") || isNeutralFence(node)) &&
        node.childNodes.length === 1);
}
export function tableIsCases(_table, prevNodes) {
    return (prevNodes.length > 0 &&
        isRole(prevNodes[prevNodes.length - 1], "openfence"));
}
export function tableIsMultiline(table) {
    return table.childNodes.every(function (row) {
        const length = row.childNodes.length;
        return length <= 1;
    });
}
export function lineIsLabelled(line) {
    return (isType(line, "line") &&
        line.contentNodes.length &&
        isRole(line.contentNodes[0], "label"));
}
export function isBinomial(table) {
    return table.childNodes.length === 2;
}
export function isLimitBase(node) {
    return (isType(node, "largeop") ||
        isType(node, "limboth") ||
        isType(node, "limlower") ||
        isType(node, "limupper") ||
        (isType(node, "function") &&
            isRole(node, "limit function")) ||
        ((isType(node, "overscore") ||
            isType(node, "underscore")) &&
            isLimitBase(node.childNodes[0])));
}
export function isSimpleFunctionHead(node) {
    return (node.type === "identifier" ||
        node.role === "latinletter" ||
        node.role === "greekletter" ||
        node.role === "otherletter");
}
export function singlePunctAtPosition(nodes, puncts, position) {
    return (puncts.length === 1 &&
        (nodes[position].type === "punctuation" ||
            nodes[position].embellished === "punctuation") &&
        nodes[position] === puncts[0]);
}
export function isSimpleFunction(node) {
    return (isType(node, "identifier") &&
        isRole(node, "simple function"));
}
function isLeftBrace(node) {
    const leftBrace = ['{', '﹛', '｛'];
    return !!node && leftBrace.indexOf(node.textContent) !== -1;
}
function isRightBrace(node) {
    const rightBrace = ['}', '﹜', '｝'];
    return !!node && rightBrace.indexOf(node.textContent) !== -1;
}
export function isSetNode(node) {
    return (isLeftBrace(node.contentNodes[0]) && isRightBrace(node.contentNodes[1]));
}
const illegalSingleton = [
    "punctuation",
    "punctuated",
    "relseq",
    "multirel",
    "table",
    "multiline",
    "cases",
    "inference"
];
const scriptedElement = [
    "limupper",
    "limlower",
    "limboth",
    "subscript",
    "superscript",
    "underscore",
    "overscore",
    "tensor"
];
export function isSingletonSetContent(node) {
    const type = node.type;
    if (illegalSingleton.indexOf(type) !== -1 ||
        (type === "infixop" && node.role !== "implicit")) {
        return false;
    }
    if (type === "fenced") {
        return node.role === "leftright"
            ? isSingletonSetContent(node.childNodes[0])
            : true;
    }
    if (scriptedElement.indexOf(type) !== -1) {
        return isSingletonSetContent(node.childNodes[0]);
    }
    return true;
}
function isNumber(node) {
    return (node.type === "number" &&
        (node.role === "integer" || node.role === "float"));
}
export function isUnitCounter(node) {
    return (isNumber(node) ||
        node.role === "vulgar" ||
        node.role === "mixed");
}
export function isPureUnit(node) {
    const children = node.childNodes;
    return (node.role === "unit" &&
        (!children.length || children[0].role === "unit"));
}
export function isUnitProduct(node) {
    const children = node.childNodes;
    return (node.type === "infixop" &&
        (node.role === "multiplication" ||
            node.role === "implicit") &&
        children.length &&
        (isPureUnit(children[0]) || isUnitCounter(children[0])) &&
        node.childNodes.slice(1).every(isPureUnit));
}
export function isImplicit(node) {
    return (node.type === "infixop" &&
        (node.role === "implicit" ||
            (node.role === "unit" &&
                !!node.contentNodes.length &&
                node.contentNodes[0].textContent === NamedSymbol.invisibleTimes)));
}
export function isImplicitOp(node) {
    return (node.type === "infixop" && node.role === "implicit");
}
export function isNeutralFence(fence) {
    return (fence.role === "neutral" || fence.role === "metric");
}
export function compareNeutralFences(fence1, fence2) {
    return (isNeutralFence(fence1) &&
        isNeutralFence(fence2) &&
        getEmbellishedInner(fence1).textContent ===
            getEmbellishedInner(fence2).textContent);
}
export function elligibleLeftNeutral(fence) {
    if (!isNeutralFence(fence)) {
        return false;
    }
    if (!fence.embellished) {
        return true;
    }
    if (fence.type === "superscript" ||
        fence.type === "subscript") {
        return false;
    }
    if (fence.type === "tensor" &&
        (fence.childNodes[3].type !== "empty" ||
            fence.childNodes[4].type !== "empty")) {
        return false;
    }
    return true;
}
export function elligibleRightNeutral(fence) {
    if (!isNeutralFence(fence)) {
        return false;
    }
    if (!fence.embellished) {
        return true;
    }
    if (fence.type === "tensor" &&
        (fence.childNodes[1].type !== "empty" ||
            fence.childNodes[2].type !== "empty")) {
        return false;
    }
    return true;
}
export function isMembership(element) {
    return [
        "element",
        "nonelement",
        "reelement",
        "renonelement"
    ].includes(element.role);
}
